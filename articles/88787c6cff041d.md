---
title: "Django REST framework でクリーンアーキテクチャ"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["python", "cleanarchitecture", "django", "djangorestframework"]
published: false
---

# はじめに
　以前働いていた職場で，Django REST framework を用いたクリーンアーキテクチャを実践していたので，今回はそれについて紹介したいと思います．初めての技術記事投稿なので，至らないところがあればご指摘いただければ幸いです．

# クリーンアーキテクチャとは
　さて，クリーンアーキテクチャとは何でしょうか？ よく引用されるのは次図です．

　![クリーンアーキテクチャ](/images/clean_arch.jpg)
　*"The Clean Architecture" (https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) より引用*

　説明については次のサイトが分かりやすいと思います：https://nrslib.com/clean-architecture/

 　要点としては，あるモジュールで別のモジュールを呼び出しているとき，呼び出している側から呼び出されている側に **依存の矢印を向かわせると，一方向のみに向かっている** というルール (Dependency Rule) を守っているものです．

 　こうすると，矢印が向かっていくアーキテクチャの中心部に位置する **ビジネスロジック (Use Case) は，周縁部にある些末な詳細 (どこに出力するかなど) のことを知らずに，その変更から保護される特権的位置を獲得** します．Use Case はフレームワークや詳細に依存しない純粋な入出力を持つものとして想定しています．それに加えて周縁部の詳細を挿げ替える (向き先を DB から In-memory にするなど) ことで，テスト容易性 (testability) も高まります．

# Django REST framework でやる
　さて，バックエンドの責務とはなんでしょうか？ 

1. HTTP リクエストを受けて，
2. 適切なユーザーであるか認証し，
3. リクエストボディのバリデーションをし，
4. 永続化されているデータを用いて何かしらの処理をして，
5. レスポンスボディとしてデータを返す

　すなわち，データの永続化とそのデータの状態を取得・変更するものだと思っています．

　上の 4. が Use Case に相当します．また，その Use Case は永続化されているデータに対応する Entity に依存するので， **Entity がもっとも中核的な部分** ということになります．

　また，Use Case の純粋な入出力を HTTP リクエスト →  レスポンス という外部の入出力関係に変換する周辺部分の詳細 (4. 以外) が Controller ということになります．

　これを Djagno REST framework で実現する方法を見ていきましょう．

# Controller
Djagno REST framework でいうと `View` です．`View` はある URL のパスに割り当てられて，**それに対する各 HTTP メソッド (`GET`, `POST`, `PUT`, `DELETE` など) に対する処理をまとめて記述** します．

コード例 (イメージ)：
```py
router = routers.SimpleRouter()

router.register(r'books', views.BookView, basename='books')

# URL 定義
urlpatterns = [
    path('', include(router.urls)),
]
```

これには，`rest-framework.viewsets.GenericViewSet` を用います．

各メソッドをまとめて記述するという `View` の性質上，Use Case をはじめとしたものを **「どのメソッドにどれを使うか」ができるだけ効率的に記述できればうれしい** です．というのも，Django REST framework ではリクエスト・レスポンスボディの形状とバリデーションを記述するための `Serializer` という仕組みがあり，それは複数のメソッドで共通あるいはデフォルトのものを指定した場合が多いと思われるからです．

```py
class BaseViewSet(viewsets.GenericViewSet):
    """
    ViewSet
    各クラス dict にて、action に対応した serializer etcが取得できる

    ```py
    serializer_class_dict = {
        'list': ListSerializer, # list 時に動作
        'retrieve': RetrieveSerializer, # retrieve 時に動作
        'default': GenericSerializer, # 上記その他で取得
    }
    ```

    action -> default -> list の順で取得

    serializer_class_dict のみ request, response Dict 可能
    serializer_class_dict = {
        'default': {
            'request': RequestSerializer,
            'response': RequestSerializer,
        }
    }

    """

    # Open API
    TAG = []

    class Meta:
        abstract = True

    # Permissions
    permission_classes_dict: Dict[str, Tuple] = {}

    # Serializer
    serializer_class_dict: Dict[str, Union[Type[serializers.Serializer],
                                           Dict[str, Type[serializers.Serializer]]]] = {}

    # Alias
    serializer_alias_dict: Dict[str, str] = {
        'list': 'datas', 'default': 'data'}
    serializer_option_alias_dict: Dict[str, str] = {'default': 'options'}

    # UseCase
    use_case_dict: Dict[str, Type[BaseUseCase]] = {}

    # Filter
    filter_set_dict: Dict[str, Type[BaseFilterSet]] = {}
```

メソッド (`action` として，`GET` → `retrieve` or `list` 等と対応している) に対応するものを dict の形で指定します．ここでは，そのような形式で `Permission`，`Serializer`，`Use Case`，`Filter` を指定しています．`Filter` とは，いわゆるクエリ (URL の `?` 以降のもの) に対応します．