---
title: "å‰è·ã§ã®å­¦ã³ #2ã€€â”€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€â”€"
emoji: "ğŸŒŠ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["python", "django"]
published: false
---

# ã¯ã˜ã‚ã«
ã€€å‰è·ã§ã®çµŒé¨“ã‚’è¸ã¾ãˆã¦ï¼Œè‡ªåˆ†ãªã‚Šã®å­¦ã³ã‚’å…±æœ‰ã—ã¦ã¿ãŸã„ã¨æ€ã„ã¾ã™ï¼[å‰å›](https://zenn.dev/utas_sqr/articles/eaa157e4a55b93) ã«å¼•ãç¶šãç¬¬äºŒå¼¾ã§ã™ï¼

ã€€ä»Šå›ã¯ï¼Œæ—¢å­˜ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’èª­ã‚€ã“ã¨ã«ã‚ˆã£ã¦ï¼Œã‚ˆã‚ŠæŸ”è»Ÿã«æ©Ÿèƒ½ã‚’æ‹¡å¼µã™ã‚‹ã‚„ã‚Šæ–¹ã‚’ã”ç´¹ä»‹ã—ã¾ã™ï¼åˆå¿ƒè€…ã«ã¨ã£ã¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹ä½¿ã„æ–¹ã‚’è¦šãˆã‚‹ã“ã¨ã«ã®ã¿çµ‚å§‹ã—ï¼Œã„ã‚ã°ãã‚ŒãŒã€Œå…¬ç†ã€ã«ãªã£ã¦ï¼Œãã‚Œä»¥ä¸Šæ·±æ˜ã‚Šã§ãã¦ã„ãªã„çŠ¶æ…‹ã«ãªã‚‹ã“ã¨ãŒå¤šã„** ã‚ˆã†ã«æ€ã„ã¾ã™ï¼ã—ã‹ã—ãªãŒã‚‰ï¼Œ**ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚‚å®Ÿè£…ã¯ã‚ã‚‹** ã‚ã‘ã§ï¼Œãã®ã‚ˆã†ãªå‰æã‚’ã•ã‚‰ã«æ˜ã‚Šé€²ã‚ã¦ã„ãã“ã¨ã§ï¼Œ**ãã®ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ç†è§£ã—ãŸã‚Šï¼Œã‚ˆã‚ŠæŸ”è»Ÿã«åˆ©ç”¨ã§ããŸã‚Šã§ãã‚‹** ã¨æ€ã„ã¾ã™ï¼

ã€€**ã“ã®ã‚ˆã†ãªã€Œè‡ªæ˜ã¨æ€ã‚ã‚Œã‚‹å‰æã‚’ã•ã‚‰ã«ç–‘ã†ã€è¦–ç‚¹ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ä¸Šé”ã®ã¿ãªã‚‰ãšï¼Œãƒ¢ãƒã®è€ƒãˆæ–¹ã«ãŠã„ã¦é‡è¦ã§ã‚ã‚‹ã‚ˆã†ã«æ€ãˆã¦ãªã‚‰ãªã„** ã®ã§ï¼Œã¾ã¨ã‚ã¦ã¿ãŸã„ã¨æ€ã„ã¾ã™ï¼

:::message
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ãŒã‚ã‚Šã¾ã™ã®ã§ï¼Œè©³ç´°ãŒçŸ¥ã‚ŠãŸã„æ–¹ã¯ãã¡ã‚‰ã‚‚åˆã‚ã›ã¦ã”å‚ç…§ãã ã•ã„ï¼
ã€€
https://github.com/asSqr/django_clean_arch
:::

# Entity (QuerySet)
Entity ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ï¼š

```py:mbook_model.py
class MBookQuerySet(QuerySet):

    def get_by_id(self, id_: str) -> Optional['MBook']:
        try:
            return self.get(id=id_)
        except MBook.DoesNotExist:
            return None

    def filter_id_in(self, id_list: List[str]) -> 'MBookQuerySet':
        return self.filter(id__in=id_list)

    def filter_eq_id(self, id_: str) -> 'MBookQuerySet':
        return self.filter(id=id_)


class MBook(BaseModel):
    '''
    æ²è¼‰å˜è¡Œæœ¬
    '''
    
    series = models.CharField(
        max_length=8192,
        choices=BookSeriesEnum.choices()
    )
    volume = models.CharField(max_length=8192)
    mgadgets = models.ManyToManyField(
        'dorapi.MGadget',
        related_name='mgadgets',
        related_query_name='mgadget',
        through='dorapi.GadgetBook',
    )

    objects = MBookQuerySet.as_soft_manager()
    object_all = MBookQuerySet.as_manager()
```

ã€€Django Model ã¨ `QuerySet` ã‚’ä¸€ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¾ã¨ã‚ã¦ã„ã¾ã™ï¼åŸºæœ¬çš„ã«ï¼ŒORM ã«ã‚ˆã‚‹å‡¦ç†ã¯ `MBookQuerySet` ã§å®šç¾©ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã ã‘ã‚’ç”¨ã„ã¦è¡Œã„ã¾ã™ (å¿…è¦ãªå‡¦ç†ãŒã‚ã‚Œã°éƒ½åº¦æ›¸ãè¶³ã—ã¦ã„ã)ï¼QuerySet ã®æ„å‘³ãŒå‘½åã«ã‚ˆã‚Šæ˜ç¤ºã§ãã‚‹ä¸Šã«ï¼Œ`get` ç­‰å­˜åœ¨ã—ãªã„ã“ã¨ãŒã‚ã‚Šã†ã‚‹å ´åˆã®ä¾‹å¤–å‡¦ç†ã‚‚éš è”½ã§ãã¾ã™ï¼

ã€€ãªãŠï¼Œã“ã“ã§ã® `QuerySet` ã¯å¾“æ¥ã® Django ã® `QuerySet` ã‚’æ‹¡å¼µã—ãŸã‚‚ã®ã§ã™ï¼š

```py:queryset.py
from django.db import models
from datetime import datetime


class QuerySet(models.QuerySet):

    def as_soft_manager(cls):
        from .manager import SoftManager
        manager = SoftManager.from_queryset(cls)()
        manager._built_with_as_manager = True
        return manager

    as_soft_manager.queryset_only = True
    as_soft_manager = classmethod(as_soft_manager)  # type: ignore

    def delete(self):
        deleted_at = datetime.now()
        objs = list(self)
        for obj in objs:
            obj.deleted_at = deleted_at

        self.bulk_update(objs, ['deleted_at'])
        return objs
```

`delete` ã«é–¢ã—ã¦ã¯å®Ÿéš›ã«å‰Šé™¤ã™ã‚‹ã®ã§ã¯ãªãï¼Œ`deleted_at` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æ›´æ–°ã—è«–ç†å‰Šé™¤ã¨ã—ã¦ã„ã¾ã™ï¼š

```py:manager.py
class SoftManager(models.Manager):

    def get_queryset(self):
        return self._queryset_class(model=self.model, using=self._db, hints=self._hints).filter(deleted_at=None)
```

`BaseModel` ã§ã‚‚åŒæ§˜ã§ã™ï¼š

```py:base_model.py
from datetime import datetime
import uuid

from django.db import models


class BaseModel(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    create_date = models.DateTimeField(auto_now_add=True)
    update_date = models.DateTimeField(auto_now=True)
    deleted_at = models.DateTimeField(default=None, null=True, blank=True)

    class Meta:
        abstract = True

    def delete(self):
        self.deleted_at = datetime.now()
        self.save()

    def hard_delete(self):
        super().delete()
